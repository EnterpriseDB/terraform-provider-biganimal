/*
BigAnimal

BigAnimal REST API v2 <br /><br /> Please visit [API v2 Changelog page](/api/docs/v2migration.html) for information about migrating from API v1. 

API version: 2.5.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// BillingApiService BillingApi service
type BillingApiService service

type ApiGetBillingRequest struct {
	ctx context.Context
	ApiService *BillingApiService
	startAt *string
	endAt *string
}

func (r ApiGetBillingRequest) StartAt(startAt string) ApiGetBillingRequest {
	r.startAt = &startAt
	return r
}

func (r ApiGetBillingRequest) EndAt(endAt string) ApiGetBillingRequest {
	r.endAt = &endAt
	return r
}

func (r ApiGetBillingRequest) Execute() (*GetBilling200Response, *http.Response, error) {
	return r.ApiService.GetBillingExecute(r)
}

/*
GetBilling Method for GetBilling

Returns organization billing usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBillingRequest
*/
func (a *BillingApiService) GetBilling(ctx context.Context) ApiGetBillingRequest {
	return ApiGetBillingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBilling200Response
func (a *BillingApiService) GetBillingExecute(r ApiGetBillingRequest) (*GetBilling200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBilling200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetBilling")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startAt == nil {
		return localVarReturnValue, nil, reportError("startAt is required and must be specified")
	}
	if r.endAt == nil {
		return localVarReturnValue, nil, reportError("endAt is required and must be specified")
	}

	localVarQueryParams.Add("startAt", parameterToString(*r.startAt, ""))
	localVarQueryParams.Add("endAt", parameterToString(*r.endAt, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Model429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Model500
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsageRequest struct {
	ctx context.Context
	ApiService *BillingApiService
	startAt *string
	endAt *string
	cloudProviderIds *[]string
	pgTypeIds *[]string
	clusterArchitecturesIds *[]string
	q *string
	sort *string
}

func (r ApiGetUsageRequest) StartAt(startAt string) ApiGetUsageRequest {
	r.startAt = &startAt
	return r
}

func (r ApiGetUsageRequest) EndAt(endAt string) ApiGetUsageRequest {
	r.endAt = &endAt
	return r
}

// Array of cloud provider IDs
func (r ApiGetUsageRequest) CloudProviderIds(cloudProviderIds []string) ApiGetUsageRequest {
	r.cloudProviderIds = &cloudProviderIds
	return r
}

// Array of pgType IDs
func (r ApiGetUsageRequest) PgTypeIds(pgTypeIds []string) ApiGetUsageRequest {
	r.pgTypeIds = &pgTypeIds
	return r
}

// Array of cloud cluster architectures
func (r ApiGetUsageRequest) ClusterArchitecturesIds(clusterArchitecturesIds []string) ApiGetUsageRequest {
	r.clusterArchitecturesIds = &clusterArchitecturesIds
	return r
}

// Fulltext search
func (r ApiGetUsageRequest) Q(q string) ApiGetUsageRequest {
	r.q = &q
	return r
}

// Sort by property of the object. Use dot notation eg. \&quot;state.city\&quot; for sorting by nested property. Default sort is ASC. Prepend with \&quot;-\&quot; for DESC sort. For numeric sorting use \&quot;size|numeric:true\&quot;. First part is property path, second part is optional parameter of the sort. Supported options are \&quot;numeric:true|false\&quot; for numeric sorting and \&quot;sensitivity:base\&quot; to compare base of the string only: a ≠ b, a &#x3D; á, a &#x3D; A.
func (r ApiGetUsageRequest) Sort(sort string) ApiGetUsageRequest {
	r.sort = &sort
	return r
}

func (r ApiGetUsageRequest) Execute() (*GetUsage200Response, *http.Response, error) {
	return r.ApiService.GetUsageExecute(r)
}

/*
GetUsage Method for GetUsage

Returns usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsageRequest
*/
func (a *BillingApiService) GetUsage(ctx context.Context) ApiGetUsageRequest {
	return ApiGetUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUsage200Response
func (a *BillingApiService) GetUsageExecute(r ApiGetUsageRequest) (*GetUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startAt == nil {
		return localVarReturnValue, nil, reportError("startAt is required and must be specified")
	}
	if r.endAt == nil {
		return localVarReturnValue, nil, reportError("endAt is required and must be specified")
	}

	localVarQueryParams.Add("startAt", parameterToString(*r.startAt, ""))
	localVarQueryParams.Add("endAt", parameterToString(*r.endAt, ""))
	if r.cloudProviderIds != nil {
		localVarQueryParams.Add("cloudProviderIds", parameterToString(*r.cloudProviderIds, "csv"))
	}
	if r.pgTypeIds != nil {
		localVarQueryParams.Add("pgTypeIds", parameterToString(*r.pgTypeIds, "csv"))
	}
	if r.clusterArchitecturesIds != nil {
		localVarQueryParams.Add("clusterArchitecturesIds", parameterToString(*r.clusterArchitecturesIds, "csv"))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Model429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Model500
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsageReportFileRequest struct {
	ctx context.Context
	ApiService *BillingApiService
	startAt *string
	endAt *string
	cloudProviderIds *[]string
	clusterArchitecturesIds *[]string
	pgTypeIds *[]string
	q *string
	sort *string
	clusterNameTitle *string
	pgTypeTitle *string
	cloudProviderTitle *string
	clusterArchitectureTitle *string
	vcpuHoursTitle *string
	deletedClusterPrefix *string
}

func (r ApiGetUsageReportFileRequest) StartAt(startAt string) ApiGetUsageReportFileRequest {
	r.startAt = &startAt
	return r
}

func (r ApiGetUsageReportFileRequest) EndAt(endAt string) ApiGetUsageReportFileRequest {
	r.endAt = &endAt
	return r
}

// Array of cloud provider IDs
func (r ApiGetUsageReportFileRequest) CloudProviderIds(cloudProviderIds []string) ApiGetUsageReportFileRequest {
	r.cloudProviderIds = &cloudProviderIds
	return r
}

// Array of cloud cluster architectures
func (r ApiGetUsageReportFileRequest) ClusterArchitecturesIds(clusterArchitecturesIds []string) ApiGetUsageReportFileRequest {
	r.clusterArchitecturesIds = &clusterArchitecturesIds
	return r
}

// Array of pgType IDs
func (r ApiGetUsageReportFileRequest) PgTypeIds(pgTypeIds []string) ApiGetUsageReportFileRequest {
	r.pgTypeIds = &pgTypeIds
	return r
}

// Fulltext search
func (r ApiGetUsageReportFileRequest) Q(q string) ApiGetUsageReportFileRequest {
	r.q = &q
	return r
}

// Sort by property of the object. Use dot notation eg. \&quot;state.city\&quot; for sorting by nested property. Default sort is ASC. Prepend with \&quot;-\&quot; for DESC sort. For numeric sorting use \&quot;size|numeric:true\&quot;. First part is property path, second part is optional parameter of the sort. Supported options are \&quot;numeric:true|false\&quot; for numeric sorting and \&quot;sensitivity:base\&quot; to compare base of the string only: a ≠ b, a &#x3D; á, a &#x3D; A.
func (r ApiGetUsageReportFileRequest) Sort(sort string) ApiGetUsageReportFileRequest {
	r.sort = &sort
	return r
}

// The cluster name columm title. The default value is Cluster Name.
func (r ApiGetUsageReportFileRequest) ClusterNameTitle(clusterNameTitle string) ApiGetUsageReportFileRequest {
	r.clusterNameTitle = &clusterNameTitle
	return r
}

// The database type column title. The default value is Database Type.
func (r ApiGetUsageReportFileRequest) PgTypeTitle(pgTypeTitle string) ApiGetUsageReportFileRequest {
	r.pgTypeTitle = &pgTypeTitle
	return r
}

// The cloud provider column title. The default value is Cloud Provider.
func (r ApiGetUsageReportFileRequest) CloudProviderTitle(cloudProviderTitle string) ApiGetUsageReportFileRequest {
	r.cloudProviderTitle = &cloudProviderTitle
	return r
}

// The cluster architecture title. The default value is Cluster Architecture.
func (r ApiGetUsageReportFileRequest) ClusterArchitectureTitle(clusterArchitectureTitle string) ApiGetUsageReportFileRequest {
	r.clusterArchitectureTitle = &clusterArchitectureTitle
	return r
}

// The usage of vCPU hour column title. The default value is vCPU Hours.
func (r ApiGetUsageReportFileRequest) VcpuHoursTitle(vcpuHoursTitle string) ApiGetUsageReportFileRequest {
	r.vcpuHoursTitle = &vcpuHoursTitle
	return r
}

// If the cluster is deleted, in Cluster Name column, it will show the deleted prefix with cluster id.
func (r ApiGetUsageReportFileRequest) DeletedClusterPrefix(deletedClusterPrefix string) ApiGetUsageReportFileRequest {
	r.deletedClusterPrefix = &deletedClusterPrefix
	return r
}

func (r ApiGetUsageReportFileRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetUsageReportFileExecute(r)
}

/*
GetUsageReportFile Method for GetUsageReportFile

Returns usage report as a CSV file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsageReportFileRequest
*/
func (a *BillingApiService) GetUsageReportFile(ctx context.Context) ApiGetUsageReportFileRequest {
	return ApiGetUsageReportFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BillingApiService) GetUsageReportFileExecute(r ApiGetUsageReportFileRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetUsageReportFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage-csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startAt == nil {
		return localVarReturnValue, nil, reportError("startAt is required and must be specified")
	}
	if r.endAt == nil {
		return localVarReturnValue, nil, reportError("endAt is required and must be specified")
	}

	localVarQueryParams.Add("startAt", parameterToString(*r.startAt, ""))
	localVarQueryParams.Add("endAt", parameterToString(*r.endAt, ""))
	if r.cloudProviderIds != nil {
		localVarQueryParams.Add("cloudProviderIds", parameterToString(*r.cloudProviderIds, "csv"))
	}
	if r.clusterArchitecturesIds != nil {
		localVarQueryParams.Add("clusterArchitecturesIds", parameterToString(*r.clusterArchitecturesIds, "csv"))
	}
	if r.pgTypeIds != nil {
		localVarQueryParams.Add("pgTypeIds", parameterToString(*r.pgTypeIds, "csv"))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.clusterNameTitle != nil {
		localVarQueryParams.Add("clusterNameTitle", parameterToString(*r.clusterNameTitle, ""))
	}
	if r.pgTypeTitle != nil {
		localVarQueryParams.Add("pgTypeTitle", parameterToString(*r.pgTypeTitle, ""))
	}
	if r.cloudProviderTitle != nil {
		localVarQueryParams.Add("cloudProviderTitle", parameterToString(*r.cloudProviderTitle, ""))
	}
	if r.clusterArchitectureTitle != nil {
		localVarQueryParams.Add("clusterArchitectureTitle", parameterToString(*r.clusterArchitectureTitle, ""))
	}
	if r.vcpuHoursTitle != nil {
		localVarQueryParams.Add("vcpuHoursTitle", parameterToString(*r.vcpuHoursTitle, ""))
	}
	if r.deletedClusterPrefix != nil {
		localVarQueryParams.Add("deletedClusterPrefix", parameterToString(*r.deletedClusterPrefix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Model429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Model500
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
